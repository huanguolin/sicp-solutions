#lang scheme

;-----------------
; 三种方式对比：
;-----------------
; 1. 三种实现方式简述
;   a) 显示分派的通用性操作：在通用操作内部通过判断数据类型来调用对应的方法
;   b) 数据导向：按照类型数据和操作方法名分类的把操作存入table,然后在通用操作
;      内部判断类型后，传入类型和操作名来取出方法
;   c) 消息传递：在构造数据时返回一个分派方法的函数（该函数便是数据本身），
;      该函数接受一个操作名的参数，通用方法的调用通过apply-generic把方法名称
;      传给数据（dispatch函数）而达成目的
;
; 2. 加入新类型导致的改动：
;   a) 编写新类型的操作方法(还要考虑命名不能冲突)，然后修改所有通用方法，
;      在其内部加上新类型判断以实现分派方法分支
;   b) 在编写新类型的方法外，需要将这些方法注册到table中去
;   c) 只需要写新类型的构造方法，并把操作该类型的方法内置于构造方法中
;  
;    从对旧代码的改动上，a) 改动最多，还要避免命名冲突，b) 和 c) 都没有改动旧
;    代码，不过 b) 有修改 table 
;
; 3. 加入新通用操作方法导致的改动：
;   a) 为每一个类型编写新方法(还要避免冲突)，并编写通用方法来分派这些类型方法
;   b) 在为每一个类型编写新方法外，还需将新方法注册
;   c) 需要修改每一个类型的构造函数来加入新方法
;   
;     从对旧代码的改动上来看，a) 都是添加，但要避免命名冲突，b) 修改较少，
;     c) 修改很多
;
; -------------
; 总结
; -------------
; 1. 经常需要加入新类型的系统，c) 最适合，b) 也可以
; 2. 经常需要加入新方法的系统，b) 最适合, a) 次之
; 3. 新类型和方法都加入频繁的, b)最适合


